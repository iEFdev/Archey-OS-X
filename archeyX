#!/usr/bin/env python3.6

"""/usr/local/bin/archeyX

Description:
   Archey X is a simple system information tool written in Python.

Licence:
  Distributed under GPLv3+: GNU General Public License v3 or later.
  See LICENSE or <https://www.gnu.org/licenses/gpl-3.0.html> for the full license text.

Author notes:
  This is a is a forked/ported version of the original script: Archey, by Melik Manukyan.
  It's made to be cross platform and able to auto detect different distros.

Original author(s) and copyright:
  (c) 2010 Melik Manukyan <melik@archlinux.us>
  (c) 2010 David Vazgenovich Shakaryan <dvshakaryan@gmail.com>

  ASCII art by Brett Bohnenkamper <kittykatt@silverirc.com>
  Changes Jerome Launay <jerome@projet-libre.org>
  Fedora support by YeOK <yeok@henpen.org>
"""

# Import libraries/resources
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from datetime import datetime, timedelta
from distutils.spawn import find_executable as fExec
from distutils.version import StrictVersion as vcomp
from getpass import getuser
from itertools import chain
from math import ceil
from os import getenv, path, uname
from re import sub, match, compile as comp
from socket import gethostname
from subprocess import check_output, PIPE, Popen
from sys import platform
from time import time

# Inform about python3.6 (force an SyntaxError)
INFO = f'Archey X requires Python 3.6+ - Please upgrade...'

# Version: use --help and --version
VERSION = 'v0.9-beta-20180618 (June 18, 2018)'  # 08:55:50
COPYRIGHT = f'Copyright (c) {datetime.now().year} Eric F'

# Settings
DISK_WARNING = 1                # default: 1 (set 0 to disable)
DISK_WARNING_THRESHOLD = 20     # default: 20 (% of diskspace left)


# Dictionaries, lists and tuples
# ------------------------------------------------------------
COLOR_PAIRS = (
    (33, 37), (34, 34), (37, 30), (36, 36),  # yellow/white, blue/blue, grey/grey, cyan/cyan
    (34, 37), (31, 31), (37, 35), (32, 37),  # blue/white, red/red, white/purple, white/green
    (32, 30), (32, 32), (34, 32),            # green/grey, green/green, blue/green
)

COLOR_VARIES = ('\x1b[0;31m', '\x1b[0;32m', '\x1b[0;33m', '\x1b[5;31m', '\x1b[0m')
COLOR_DICT = {f'color{c:02d}': (f'\x1b[0;{n}m', f'\x1b[1;{b}m')
              for c, (n, b) in enumerate(COLOR_PAIRS)}

DIST_DICT = {
    'GNU/Linux': 'color00', 'Arch Linux': 'color01', 'Crunchbang': 'color02',
    'Darwin': 'color03', 'Mac OS X': 'color03', 'Fedora': 'color04',
    'RHEL': 'color05', 'Debian': 'color05', 'Ubuntu': 'color05',
    'Gentoo': 'color06', 'LinuxMint': 'color07', 'SLES': 'color08',
    'OpenSUSE': 'color09', 'CentOS': 'color10',
}

DE_DICT = {
    'cinnamon-sessio': 'Cinnamon', 'Finder': 'Finder', 'gnome-session': 'GNOME',
    'ksmserver': 'KDE', 'lxsession': 'LXDE', 'mate-session': 'MATE',
    'xfce4-session': 'Xfce'
}

WM_DICT = {
    'awesome': 'Awesome', 'beryl': 'Beryl', 'blackbox': 'Blackbox', 'bspwm': 'bspwm',
    'compiz': 'Compiz', 'dwm': 'DWM', 'enlightenment': 'Enlightenment',
    'fluxbox': 'Fluxbox', 'fvwm': 'FVWM', 'herbstluftwm': 'herbstluftwm',
    'i3': 'i3', 'icewm': 'IceWM', 'kwin': 'KWin',
    'metacity': 'Metacity', 'musca': 'Musca', 'nemo': 'Nemo',
    'openbox': 'Openbox', 'pekwm': 'PekWM', 'ratpoison': 'ratpoison',
    'scrotwm': 'ScrotWM', 'wmaker': 'Window Maker', 'wmfs': 'Wmfs',
    'wmii': 'wmii', 'xfwm4': 'Xfwm', 'xmonad': 'xmonad',

    # OS X/macOS
    'Cinch': 'Cinch', 'Factory': 'Factory', 'Mizage': 'Mizage',
    'Moom': 'Moom', 'Optimal Layout': 'Optimal Layout', 'ShiftIt': 'ShiftIt',
    'SizeUp': 'SizeUp', 'Slate': 'Slate', 'Slicer': 'Slicer',
    'Spectacle': 'Spectacle', 'TylerWM': 'TylerWM', 'Xmonad': 'Xmonad'
}

OSX_VERS = ('Tiger', 'Leopard', 'Snow Leopard', 'Lion', 'Mountain Lion', 'Mavericks',
            'Yosemite', 'El Capitan', 'Sierra', 'High Sierra', 'Mojave')

OSX_DICT = {f'10.{x}': y for x, y in enumerate(OSX_VERS, 4)}

PM_DICT = {
    'pacman': ['-Q'], 'emerge': ['-ep', 'world'], 'zypper': ['search', '--installed-only'],
    'dnf': ['list', 'installed'], 'yum': ['list', 'installed'], 'dpkg': ['--get-selections'],

    'port': ['installed'], 'fink': ['list', '-i'], 'brew': ['list']     # OS X/macOS
}

LABELS = ('User', 'Hostname', 'Distro', 'Kernel', 'Uptime', 'WindowManager',
          'DesktopEnvironment', 'Shell', 'Terminal', 'Packages', 'CPU', 'RAM', 'Disk')

CLASSES = {x: x for x in LABELS}

# List of filesystemes to be included in 'df'
FS_TYPES = ('apfs', 'btrfs', 'ext2', 'ext3', 'ext4', 'fat32', 'fuseblk', 'hfs',
            'jfs', 'msdos', 'ntfs', 'reiserfs', 'simfs', 'tempfs', 'xfs', 'zfs')


# ArgumentParser - help/options
# ------------------------------------------------------------
__version__ = f'%(prog)s {VERSION}\n{COPYRIGHT}\v'
PARSER = ArgumentParser(prog='archeyX', formatter_class=RawDescriptionHelpFormatter,
                        add_help=False, conflict_handler='resolve')
PARSER.add_argument('-h', '--help', action='help', help='Show this help message and exit')
PARSER.add_argument('-V', '--version', action='version', version=__version__,
                    help='Show program\'s version number and exit')
PARSER.add_argument('-b', dest='brand', default=None, nargs=1, type=str)  # @todo: column width
PARSER.add_argument('--brand', dest='brand', default=None, nargs=1, type=str,
                    help='''You can pass in a Brand/distro name for another color.
                    The name must exist in DIST_DICT (ie. Arch Linux, Fedora, Debian etc.)''')

MACOS = PARSER.add_argument_group('OS X/Darwin (only)')
MACOS.add_argument('-a', '--apple', dest='apple', action='store_true',
                   help='''If your system is Darwin you can pass `-a' to
                   display the Apple instead. (A left-over from the bash-script.)''')

if __name__ == "__main__":
    BRAND = None
    ARGS = PARSER.parse_args()
    if ARGS.brand and ARGS.brand[0] in DIST_DICT:
        BRAND = ARGS.brand[0]
    elif ARGS.apple is True:
        BRAND = 'Apple'


# Classes
# ------------------------------------------------------------
class Utils(object):
    """Misc functions/tools"""

    @classmethod
    def x_popen(cls, cmd):
        """x_popen - less code and easier to use"""
        get_cmd = Popen(cmd, stdout=PIPE).communicate()[0].decode('utf-8').rstrip('\n')
        return get_cmd

    def x_system(self, system='Linux'):
        """x_system - Linux, Darwin etc"""
        brand = self.capitilize_name(platform).replace('2', '').strip()
        return True if system == brand and brand != '' else False

    def x_process(self):
        """x_process - get the processes to find name of WM/DE"""
        if self.x_system('Linux'):
            procs = str(check_output(('ps', '-u', getuser(), '-o', 'comm',
                                      '--no-headers')).decode('utf8')).rstrip('\n').split('\n')
        elif self.x_system('Darwin'):
            procs = str(check_output(('ps', '-u', getuser(), '-o',
                                      'comm')).decode('utf-8').split('/')).replace('\\n', '')

        return procs if procs else None

    @classmethod
    def capitilize_name(cls, text):
        """capitilize_name - fooBar becomes FooBar and not Foobar"""
        txt = comp(r'\s+').sub(' ', text).strip()
        return ' '.join(word[0].upper() + word[1:] for word in txt.split(' '))

    @classmethod
    def read_release_files(cls, file, search):
        """read_release_files - reading misc release files
        # read_release_files(<file>, <search>[, <split char>])"""
        with open(file, 'r') as lines:
            for rel in lines:
                if match(search, rel.lower()):
                    return rel.replace('"', '').strip().split('=')[1]
            return


class Output(Utils):
    """Function and tools for the Output"""
    results = []
    results.extend([''] * (18 - len(LABELS)))

    def __init__(self):
        """default to GNU/Linux if no distro"""
        distro = self.x_distro('name').rstrip()
        self.distro = 'GNU/Linux' if distro not in DIST_DICT else distro

        brand_color = self.distro if BRAND not in DIST_DICT else BRAND
        self.color = DIST_DICT.get(brand_color, distro)

    def x_distro(self, name):
        """x_distro: determing what distro is being used, both name and full name
        platform.linux_distribution() is not used. It's deprecated and flagged for removal
        """
        distro_name = distro_full = '' if self.x_system('Darwin') else 'GNU/Linux'

        if self.x_system('Darwin'):
            get_name = self.x_popen(['sw_vers', '-productName'])
            get_version = self.x_popen(['sw_vers', '-productVersion'])
            osx_name = self.x_popen(['sw_vers', '-buildVersion'])

            get_name = 'macOS' if vcomp(get_version[:-2]) >= vcomp('10.12') else get_name \
                       or get_name if vcomp(get_version[:-2]) <= vcomp('10.7') else 'OS X'
            osx_name = OSX_DICT.get(get_version[:-2], osx_name)  # get fancy names

            distro_name = 'Darwin'
            distro_full = f'{get_name} {get_version} ({osx_name})'

        # (*BSD... Hopefully at some point)
        # elif self.x_system('FreeBSD') or self.x_system('OpenBSD'):
        #     distro = distro_full = self.x_system()

        elif self.x_system('Linux'):
            rel_files = ('/etc/os-release', '/usr/lib/os-release',  # in case of missing symlink
                         '/etc/lsb-release', '/etc/issue')

            os_release = rel_files[0] if path.exists(rel_files[0]) else rel_files[1]

            if path.exists(os_release):
                distro_name = self.read_release_files(os_release, 'name')
                distro_full = self.read_release_files(os_release, 'pretty')
            elif fExec('lsb_release'):
                distro_name = self.x_popen(['lsb_release', '-si'])
                distro_full = self.x_popen(['lsb_release', '-sd'])
            elif path.exists(rel_files[2]):
                distro_name = self.read_release_files(rel_files[2], 'distrib_id')
                distro_full = self.read_release_files(rel_files[2], 'distrib_description')
            elif path.exists(rel_files[3]):
                with open(rel_files[3], 'r') as issue:
                    i = issue.readline()
                    distro_name = sub('Red', 'RHEL', i.split(' ')[0].rstrip())
                    distro_full = i.split(' \\')[0].rstrip()

        distro_full = sub('Red Hat', 'RHEL', distro_full)
        distro_full = sub('S[Uu]SE', 'SLES', distro_full)

        x_distro_names = {'name': distro_name, 'full': distro_full}
        return sub('release | GNU/Linux|Linux |Enterprise |Server ', '', x_distro_names[name])

    def append(self, display):
        """append: preparing the output"""
        self.results.append(f'{COLOR_DICT[self.color][1]}{display.key}: '
                            f'{COLOR_VARIES[-1]}{display.value}')

    def output(self):
        """output: matching name/colors"""
        return LOGOS_DICT[self.distro].format(color=COLOR_DICT[self.color], results=self.results)


class User(Utils):
    """Get the username"""
    def __init__(self):
        self.key, self.value = 'User', getuser()


class Hostname(Utils):
    """Get the hostname"""
    def __init__(self):
        self.key, self.value = 'Hostname', gethostname()


class Distro(Output, Utils):
    """Display the Distro name"""
    def __init__(self):
        self.key, self.value = 'Distro', self.x_distro('full')
        super().__init__()


class Kernel(Utils):
    """Get the kernel name"""
    def __init__(self):
        if self.x_system('Darwin'):
            kernel = f'{uname()[0]} {uname()[2]} {uname()[4]}'  # Darwin 12.3.4 x86_64
            # kernel = sub('.*:+', '', uname()[3]).strip('REL.*')  # xnu-123...
        else:
            kernel = self.x_popen(['uname', '-r'])

        self.key, self.value = 'Kernel', kernel


class Uptime(Utils):
    """Uptime: N day(s), HH:MM"""
    def __init__(self):
        if self.x_system('Darwin'):
            boot_time = self.x_popen(['sysctl', '-n', 'kern.boottime'])
            boot_time = boot_time.split()[3][:-1]
            boot_time = int(round(time())) - int(boot_time)
        else:
            with open('/proc/uptime', 'r') as utime:
                boot_time = utime.read().split('.')[0]

        uptime = f'{timedelta(seconds=int(boot_time))}'[:-3]
        self.key, self.value = 'Uptime', uptime


class WindowManager(Utils):
    """Get the name of the Window Manager
    # Default WM's: OS X = Quartz, Linux = ''"""
    def __init__(self):
        window_manager = 'Quartz' if self.x_system('Darwin') else ''

        for key in WM_DICT:
            if key in self.x_process():
                window_manager = WM_DICT[key]
                break

        self.key, self.value = 'Window Manager', window_manager


class DesktopEnvironment(Utils):
    """Get Desktop Environment"""
    def __init__(self):
        desktop_enviroment = ''

        for key in DE_DICT:
            if key in self.x_process():
                desktop_enviroment = DE_DICT[key]
                break

        self.key, self.value = 'Desktop Environment', desktop_enviroment


class Shell(Utils):
    """Shell name"""
    def __init__(self):
        self.key, self.value = 'Shell', getenv('SHELL')


class Terminal(Utils):
    """Terminal name"""
    def __init__(self):
        self.key, self.value = 'Terminal', getenv('TERM')


class Packages(Utils):
    """Get the number of installed packages"""
    def __init__(self):
        packages = ''
        if fExec('dnf') and fExec('yum'):   # ie. if Fedora, skip yum
            del PM_DICT['yum']
        elif fExec('yum'):
            del PM_DICT['dnf']

        for pman in PM_DICT:
            if fExec(pman):
                PM_DICT[pman].insert(0, pman)
                pkgs0 = packages + '\n' + self.x_popen(PM_DICT[pman])
                pkgs1 = self.x_popen(PM_DICT[pman]).rstrip('\n')
                packages = pkgs0 if packages != '' else pkgs1

        packages = 'n/a' if packages == '' else len(packages.rstrip('\n').split('\n'))

        self.key, self.value = 'Packages', packages


class CPU(Utils):
    """Display the CPU information"""
    def __init__(self):
        cpu_info = 'n/a'
        if self.x_system('Linux'):
            with open('/proc/cpuinfo') as cpu:
                cpu_info = sub('  +', ' ', cpu.readlines()[4])
        elif self.x_system('Darwin'):
            cpu = self.x_popen(['sysctl', '-n', 'machdep.cpu.brand_string'])
            cpu_info = sub('  +', ' ', cpu)

        self.key, self.value = 'CPU', sub('model name\t: |CPU ', '', cpu_info).strip()


class RAM(Utils):
    """Calculate the RAM usage and format to display
    # RAM: usedMB, freeMB of totalGB"""
    def __init__(self):
        if self.x_system('Linux'):
            raminfo = self.x_popen(['free', '-m', '--si']).split('\n')
            ram = ''.join(filter(comp('M').search, raminfo)).split()
            total_ram = round(float(ram[1]) / 1000, 2)
            used_ram = int(ram[2])
            total_free = int(ram[3]) + int(ram[5])
            # If <= 3.3.9, we need to add some parts
            if vcomp(self.x_popen(['free', '-V']).split()[-1]) <= vcomp('3.3.9'):
                used_ram = used_ram - int(ram[5]) - int(ram[6])
                total_free = total_free + int(ram[6])
        elif self.x_system('Darwin'):
            mem_size = self.x_popen(['sysctl', '-n', 'hw.memsize'])
            total_ram = int(mem_size) / 1073741824

            get_memory = self.x_popen(['vm_stat']).replace('.', '')
            get_memory = sub(r':[\s]+', ' ', get_memory.replace('Pages ', '')).split('\n')
            mem = {}
            for row in range(1, len(get_memory) - 7):
                row = get_memory[row].replace('down', '').splitlines()[0].strip().split()
                mem[(row[0])] = int(row[1]) * 4000
            # [note] Using 4000 (eg 4096) makes it sum up exactly as in Activity Monitor

            used_ram = ceil((mem['wired'] + mem['active'] +
                             mem['inactive']) / 1048576 / 10.0) * 10
            total_free = ceil((mem['free'] + mem['speculative']) / 1048576 / 10.0) * 10
        else:
            used_ram = total_ram = total_free = '-'

        red, grn, clr = (COLOR_VARIES[0], COLOR_VARIES[1], COLOR_VARIES[-1])
        ram_display = f'{red}{used_ram}MB{clr}, {grn}{total_free}MB{clr} of {total_ram}GB'

        self.key, self.value = 'RAM', ram_display


class Disk(Utils):
    """Calculate the disk usage and format to display
    # disk_vars: used, capacity, size, available, disknr
    # Display: used (%) of total, N available (disk)"""
    def __init__(self):
        if self.x_system('Linux'):
            filesystems = tuple(zip(('-t',) * len(FS_TYPES), FS_TYPES))
            pass1 = self.x_popen(list(chain(['df', '-HlPT', '--total'], *filesystems)))
            total = tuple(sub('%', '', t) for t in pass1.splitlines()[-1].split())
            disknr, size, used, avail, capacity = total[1:-1]
            disk = self.x_popen(['df', '/boot']).splitlines()[1].split()[0]
            disknr = disk.replace('/dev/', '')
        elif self.x_system('Darwin'):
            pass1 = self.x_popen(['df', '-HT', ','.join(FS_TYPES)])
            total = tuple(sub('(/dev/|%)', '', t) for t in pass1.splitlines()[1].split())
            disknr, size, used, avail, capacity = total[:-1]

        used_percent = int(capacity) if capacity else '-'

        disk_color = 1
        disk_color = 2 if used_percent >= 50 else disk_color
        disk_color = 0 if used_percent >= 80 else disk_color
        if DISK_WARNING == 1 and (100 - used_percent) <= DISK_WARNING_THRESHOLD:
            disk_color = 3

        col, clr = (COLOR_VARIES[disk_color], COLOR_VARIES[-1])
        disk_display = f'{col}{used}B{clr} ({capacity}%) of {size}B, ' \
                       f'{avail}B available ({disknr})'

        self.key, self.value = 'Disk', disk_display


# Start output
OUT = Output()

LOGOS_DICT = {OUT.distro: '''
{color[1]}               +                {results[0]}
{color[1]}               #                {results[1]}
{color[1]}              ###               {results[2]}
{color[1]}             #####              {results[3]}
{color[1]}             ######             {results[4]}
{color[1]}            ; #####;            {results[5]}
{color[1]}           +##.#####            {results[6]}
{color[1]}          +##########           {results[7]}
{color[1]}         ######{color[0]}#####{color[1]}##;         {results[8]}
{color[1]}        ###{color[0]}############{color[1]}+        {results[9]}
{color[1]}       #{color[0]}######   #######        {results[10]}
{color[0]}     .######;     ;###;`\".      {results[11]}
{color[0]}    .#######;     ;#####.       {results[12]}
{color[0]}    #########.   .########`     {results[13]}
{color[0]}   ######'           '######    {results[14]}
{color[0]}  ;####                 ####;   {results[15]}
{color[0]}  ##'                     '##   {results[16]}
{color[0]} #'                         `#  {results[17]}
\x1b[0m'''}

# (OSX/macOS only) see --help
if OUT.distro == 'Darwin' and BRAND == 'Apple':
    LOGOS_DICT = {OUT.distro: '''
{color[1]}                     ##         {results[0]}
{color[1]}                  #####         {results[1]}
{color[1]}                 #####          {results[2]}
{color[1]}               #####            {results[3]}
{color[1]}               ###              {results[4]}
{color[1]}        #####      #####        {results[5]}
{color[1]}    #####################{color[0]}#      {results[6]}
{color[1]}  ###################{color[0]}#######    {results[7]}
{color[1]} ################{color[0]}#########      {results[8]}
{color[1]} #############{color[0]}###########       {results[9]}
{color[1]} ##########{color[0]}#############        {results[10]}
{color[1]} #######{color[0]}#################       {results[11]}
{color[1]} #####{color[0]}#####################     {results[12]}
{color[1]}  ###{color[0]}#######################    {results[13]}
{color[1]}   #{color[0]}#######################     {results[14]}
{color[0]}     #####################      {results[15]}
{color[0]}      ##################        {results[16]}
{color[0]}        ####      ####          {results[17]}
\x1b[0m'''}

# Display output
if __name__ == "__main__":
    for x in LABELS:
        OUT.append(vars()[CLASSES[x]]())
    print(OUT.output())
    exit(0)
else:
    exit(1)
